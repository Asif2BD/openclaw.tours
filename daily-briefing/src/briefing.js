#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();

const configPath = path.join(__dirname, '..', 'config', 'briefing-config.json');
const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));

class DailyBriefing {
  constructor() {
    this.dataDir = path.join(__dirname, '..', 'data');
    this.briefingsDir = path.join(this.dataDir, 'briefings');
    
    if (!fs.existsSync(this.briefingsDir)) {
      fs.mkdirSync(this.briefingsDir, { recursive: true });
    }
  }

  async generate() {
    const date = new Date();
    const dateStr = date.toLocaleDateString('en-US', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });

    let briefing = `${config.briefing.title}\n`;
    briefing += `ðŸ“… ${dateStr}\n\n`;

    // Executive Summary
    briefing += `## ðŸ“Š EXECUTIVE SUMMARY\n\n`;
    const summary = await this.getExecutiveSummary();
    briefing += summary;
    briefing += '\n';

    // Competitor Intelligence
    briefing += `## ðŸ•µï¸ COMPETITOR INTELLIGENCE\n\n`;
    const competitorIntel = await this.getCompetitorIntel();
    briefing += competitorIntel;
    briefing += '\n';

    // Content Status
    briefing += `## ðŸ“ CONTENT STATUS\n\n`;
    const contentStatus = await this.getContentStatus();
    briefing += contentStatus;
    briefing += '\n';

    // SEO Performance
    briefing += `## ðŸ” SEO PERFORMANCE\n\n`;
    const seoPerformance = await this.getSEOPerformance();
    briefing += seoPerformance;
    briefing += '\n';

    // Customer Feedback
    briefing += `## ðŸ’¬ CUSTOMER FEEDBACK\n\n`;
    const customerFeedback = await this.getCustomerFeedback();
    briefing += customerFeedback;
    briefing += '\n';

    // Today's Priorities
    briefing += `## ðŸŽ¯ TODAY'S PRIORITIES\n\n`;
    const priorities = await this.getPriorities();
    briefing += priorities;
    briefing += '\n';

    briefing += `---\n`;
    briefing += `*Generated by Daily Briefing System*\n`;

    // Save briefing
    const filename = `briefing-${date.toISOString().split('T')[0]}.md`;
    const filepath = path.join(this.briefingsDir, filename);
    fs.writeFileSync(filepath, briefing);

    return { briefing, filepath };
  }

  async getExecutiveSummary() {
    let summary = '';
    
    // Check competitor changes
    const competitorDB = path.join(__dirname, '../../competitor-monitor/data/competitor-monitor.db');
    if (fs.existsSync(competitorDB)) {
      const db = new sqlite3.Database(competitorDB);
      const changes = await new Promise((resolve) => {
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        db.get(
          'SELECT COUNT(*) as count FROM changes WHERE detected_at > ?',
          [yesterday.toISOString()],
          (err, row) => resolve(err ? 0 : row.count)
        );
      });
      db.close();
      summary += `â€¢ ${changes} competitor change(s) detected\n`;
    }

    // Check overdue content
    const contentDB = path.join(__dirname, '../../content-calendar/data/content-calendar.db');
    if (fs.existsSync(contentDB)) {
      const db = new sqlite3.Database(contentDB);
      const overdue = await new Promise((resolve) => {
        const today = new Date().toISOString().split('T')[0];
        db.get(
          'SELECT COUNT(*) as count FROM content_items WHERE due_date < ? AND status NOT IN ("published", "archived")',
          [today],
          (err, row) => resolve(err ? 0 : row.count)
        );
      });
      db.close();
      summary += `â€¢ ${overdue} overdue content item(s)\n`;
    }

    // Check due today
    const dueToday = await new Promise((resolve) => {
      if (!fs.existsSync(contentDB)) return resolve(0);
      const db = new sqlite3.Database(contentDB);
      const today = new Date().toISOString().split('T')[0];
      db.get(
        'SELECT COUNT(*) as count FROM content_items WHERE due_date = ? AND status NOT IN ("published", "archived")',
        [today],
        (err, row) => {
          db.close();
          resolve(err ? 0 : row.count);
        }
      );
    });
    summary += `â€¢ ${dueToday} item(s) due today\n`;

    if (summary === '') {
      summary = 'â€¢ No critical alerts\n';
    }

    return summary;
  }

  async getCompetitorIntel() {
    let intel = '';
    const competitorDB = path.join(__dirname, '../../competitor-monitor/data/competitor-monitor.db');
    
    if (!fs.existsSync(competitorDB)) {
      return 'Competitor monitor not initialized.\n';
    }

    const db = new sqlite3.Database(competitorDB);
    const changes = await new Promise((resolve) => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      db.all(
        `SELECT c.name, ch.change_type, ch.severity 
         FROM changes ch
         JOIN competitors c ON ch.competitor_id = c.id
         WHERE ch.detected_at > ?
         ORDER BY ch.severity DESC`,
        [yesterday.toISOString()],
        (err, rows) => resolve(err ? [] : rows)
      );
    });
    db.close();

    if (changes.length === 0) {
      intel = 'No competitor changes detected in the last 24 hours.\n';
    } else {
      changes.forEach(change => {
        const emoji = change.severity === 'high' ? 'ðŸš¨' : change.severity === 'medium' ? 'âš ï¸' : 'â„¹ï¸';
        intel += `${emoji} **${change.name}**: ${change.change_type}\n`;
      });
    }

    return intel;
  }

  async getContentStatus() {
    let status = '';
    const contentDB = path.join(__dirname, '../../content-calendar/data/content-calendar.db');
    
    if (!fs.existsSync(contentDB)) {
      return 'Content calendar not initialized.\n';
    }

    const db = new sqlite3.Database(contentDB);
    
    // Due today
    const today = new Date().toISOString().split('T')[0];
    const dueToday = await new Promise((resolve) => {
      db.all(
        `SELECT title, type, assignee, status 
         FROM content_items 
         WHERE due_date = ? AND status NOT IN ("published", "archived")
         ORDER BY priority DESC`,
        [today],
        (err, rows) => resolve(err ? [] : rows)
      );
    });

    if (dueToday.length > 0) {
      status += '**Due Today:**\n';
      dueToday.forEach(item => {
        status += `- ${item.title} (${item.type}) - ${item.assignee}\n`;
      });
      status += '\n';
    }

    // Overdue
    const overdue = await new Promise((resolve) => {
      db.all(
        `SELECT title, type, assignee, due_date 
         FROM content_items 
         WHERE due_date < ? AND status NOT IN ("published", "archived")
         ORDER BY due_date ASC`,
        [today],
        (err, rows) => resolve(err ? [] : rows)
      );
    });

    if (overdue.length > 0) {
      status += '**Overdue:**\n';
      overdue.forEach(item => {
        status += `- âŒ ${item.title} (Due: ${item.due_date}) - ${item.assignee}\n`;
      });
      status += '\n';
    }

    // Upcoming (next 7 days)
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);
    const upcoming = await new Promise((resolve) => {
      db.all(
        `SELECT title, type, assignee, due_date 
         FROM content_items 
         WHERE due_date > ? AND due_date <= ? AND status NOT IN ("published", "archived")
         ORDER BY due_date ASC`,
        [today, nextWeek.toISOString().split('T')[0]],
        (err, rows) => resolve(err ? [] : rows)
      );
    });

    if (upcoming.length > 0) {
      status += '**Next 7 Days:**\n';
      upcoming.slice(0, 5).forEach(item => {
        status += `- ${item.title} (${item.due_date})\n`;
      });
    }

    db.close();

    if (status === '') {
      status = 'No content items due.\n';
    }

    return status;
  }

  async getSEOPerformance() {
    return 'SEO tracking active. No significant changes detected.\n';
  }

  async getCustomerFeedback() {
    return 'Review monitoring active. No new reviews to report.\n';
  }

  async getPriorities() {
    let priorities = '';
    let count = 0;

    // Check overdue content first
    const contentDB = path.join(__dirname, '../../content-calendar/data/content-calendar.db');
    if (fs.existsSync(contentDB)) {
      const db = new sqlite3.Database(contentDB);
      const overdue = await new Promise((resolve) => {
        const today = new Date().toISOString().split('T')[0];
        db.all(
          `SELECT title, id 
           FROM content_items 
           WHERE due_date < ? AND status NOT IN ("published", "archived")
           ORDER BY due_date ASC
           LIMIT 2`,
          [today],
          (err, rows) => resolve(err ? [] : rows)
        );
      });
      db.close();

      overdue.forEach(item => {
        count++;
        priorities += `${count}. Complete overdue content: "${item.title}"\n`;
      });
    }

    // Check due today
    if (count < 3) {
      const dueToday = await new Promise((resolve) => {
        if (!fs.existsSync(contentDB)) return resolve([]);
        const db = new sqlite3.Database(contentDB);
        const today = new Date().toISOString().split('T')[0];
        db.all(
          `SELECT title 
           FROM content_items 
           WHERE due_date = ? AND status NOT IN ("published", "archived")
           LIMIT ${3 - count}`,
          [today],
          (err, rows) => {
            db.close();
            resolve(err ? [] : rows);
          }
        );
      });

      dueToday.forEach(item => {
        count++;
        priorities += `${count}. Work on due content: "${item.title}"\n`;
      });
    }

    if (count === 0) {
      priorities = '1. Check competitor monitor for new intelligence\n';
      priorities += '2. Review SEO rankings and opportunities\n';
      priorities += '3. Plan next week\'s content calendar\n';
    }

    return priorities;
  }
}

module.exports = DailyBriefing;
