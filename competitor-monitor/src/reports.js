const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');

const DB_PATH = path.join(__dirname, '..', 'data', 'competitor-monitor.db');

class ReportGenerator {
  constructor() {
    this.db = new sqlite3.Database(DB_PATH);
  }

  async generateDailyReport(date = new Date()) {
    const dateStr = date.toISOString().split('T')[0];
    const startOfDay = `${dateStr}T00:00:00Z`;
    const endOfDay = `${dateStr}T23:59:59Z`;

    const changes = await this.getChangesForPeriod(startOfDay, endOfDay);
    const stats = await this.getStatsForPeriod(startOfDay, endOfDay);

    let report = `# Competitor Monitor - Daily Report\n`;
    report += `**Date:** ${dateStr}\n\n`;

    report += `## Summary\n`;
    report += `- Total changes detected: ${stats.total_changes}\n`;
    report += `- High severity: ${stats.high_severity}\n`;
    report += `- Medium severity: ${stats.medium_severity}\n`;
    report += `- Low severity: ${stats.low_severity}\n\n`;

    if (changes.length > 0) {
      report += `## Changes Detected\n\n`;
      
      // Group by competitor
      const byCompetitor = {};
      changes.forEach(change => {
        if (!byCompetitor[change.competitor_name]) {
          byCompetitor[change.competitor_name] = [];
        }
        byCompetitor[change.competitor_name].push(change);
      });

      for (const [competitor, compChanges] of Object.entries(byCompetitor)) {
        report += `### ${competitor}\n`;
        compChanges.forEach(change => {
          const emoji = change.severity === 'high' ? 'ðŸš¨' : change.severity === 'medium' ? 'âš ï¸' : 'â„¹ï¸';
          report += `- ${emoji} **${change.change_type}** (${change.severity})\n`;
          report += `  - Time: ${new Date(change.detected_at).toLocaleString()}\n`;
          if (change.old_value && change.new_value) {
            report += `  - Changed from: "${change.old_value.substring(0, 100)}..."\n`;
            report += `  - Changed to: "${change.new_value.substring(0, 100)}..."\n`;
          }
        });
        report += '\n';
      }
    } else {
      report += `## No Changes Detected\n`;
      report += `No competitor changes were detected today.\n\n`;
    }

    report += `---\n`;
    report += `*Report generated by Competitor Monitor*\n`;

    return report;
  }

  async generateWeeklyReport(endDate = new Date()) {
    const startDate = new Date(endDate);
    startDate.setDate(startDate.getDate() - 7);

    const startStr = startDate.toISOString().split('T')[0];
    const endStr = endDate.toISOString().split('T')[0];

    const changes = await this.getChangesForPeriod(
      startDate.toISOString(),
      endDate.toISOString()
    );

    let report = `# Competitor Monitor - Weekly Report\n`;
    report += `**Period:** ${startStr} to ${endStr}\n\n`;

    report += `## Weekly Summary\n`;
    report += `- Total changes: ${changes.length}\n`;
    
    // Competitor activity
    const byCompetitor = {};
    changes.forEach(change => {
      if (!byCompetitor[change.competitor_name]) {
        byCompetitor[change.competitor_name] = 0;
      }
      byCompetitor[change.competitor_name]++;
    });

    report += `- Most active competitor: ${this.getMostActive(byCompetitor)}\n\n`;

    report += `## Competitor Activity\n`;
    for (const [competitor, count] of Object.entries(byCompetitor)) {
      report += `- ${competitor}: ${count} change(s)\n`;
    }
    report += '\n';

    report += `## Key Insights\n`;
    if (changes.length === 0) {
      report += `- No significant competitor activity this week\n`;
      report += `- Market appears stable\n`;
    } else {
      report += `- ${changes.length} total changes detected\n`;
      const highSeverity = changes.filter(c => c.severity === 'high').length;
      if (highSeverity > 0) {
        report += `- ${highSeverity} high-severity changes require attention\n`;
      }
    }
    report += '\n';

    report += `---\n`;
    report += `*Weekly report generated by Competitor Monitor*\n`;

    return report;
  }

  async getChangesForPeriod(startDate, endDate) {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT c.*, comp.name as competitor_name
         FROM changes c
         JOIN competitors comp ON c.competitor_id = comp.id
         WHERE c.detected_at BETWEEN ? AND ?
         ORDER BY c.detected_at DESC`,
        [startDate, endDate],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  async getStatsForPeriod(startDate, endDate) {
    return new Promise((resolve, reject) => {
      this.db.get(
        `SELECT 
          COUNT(*) as total_changes,
          SUM(CASE WHEN severity = 'high' THEN 1 ELSE 0 END) as high_severity,
          SUM(CASE WHEN severity = 'medium' THEN 1 ELSE 0 END) as medium_severity,
          SUM(CASE WHEN severity = 'low' THEN 1 ELSE 0 END) as low_severity
         FROM changes
         WHERE detected_at BETWEEN ? AND ?`,
        [startDate, endDate],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });
  }

  getMostActive(byCompetitor) {
    let max = 0;
    let mostActive = 'None';
    for (const [comp, count] of Object.entries(byCompetitor)) {
      if (count > max) {
        max = count;
        mostActive = comp;
      }
    }
    return `${mostActive} (${max})`;
  }

  saveReport(reportType, content, date) {
    const reportsDir = path.join(__dirname, '..', 'data', 'reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }

    const dateStr = date.toISOString().split('T')[0];
    const filename = `${reportType}-${dateStr}.md`;
    const filepath = path.join(reportsDir, filename);

    fs.writeFileSync(filepath, content);
    return filepath;
  }

  close() {
    this.db.close();
  }
}

module.exports = ReportGenerator;
